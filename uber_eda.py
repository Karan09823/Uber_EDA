# -*- coding: utf-8 -*-
"""Uber_EDA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17DifKYBCuuIITi78f0GaIGVpVEdJeTtG
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# from google.colab import files
# uploaded_file=files.upload_file("Uber_data")

df = pd.read_excel("/content/Uber_data")

df.head()

df.columns

# standardize column names
df.columns = df.columns.str.lower().str.replace(' ', '_')
df.columns

df.isnull().sum()

# Fill missing driver ID with -1 (indicates unassigned)
df['driver_id']=df['driver_id'].fillna(-1)

# Fill missing payment method with mode
df['payment_method']=df['payment_method'].fillna(df['payment_method'].mode()[0])

# Drop rows where timestamps are missing only for 'Trip Completed'
df = df[~((df['trip_status'] == 'Trip Completed') & (df['start_timestamp'].isna() | df['drop_timestamp'].isna()))]

df.isnull().sum()

# Convert date columns to datetime
date_columns = ['request_timestamp', 'start_timestamp', 'drop_timestamp']
for col in date_columns:
    df[col] = pd.to_datetime(df[col])

#  List all numeric columns
numeric_columns = df.select_dtypes(include='number').columns.tolist()
print(numeric_columns)

#Outlier detection - Trip Cost

# Plot boxplot for trip cost
plt.figure(figsize=(8, 4))
df['trip_cost'].plot(kind='box', vert=False)
plt.title('trip_cost Distribution')
plt.show()

# Detect and cap outliers in trip cost using IQR
Q1 = df['trip_cost'].quantile(0.25)
Q3 = df['trip_cost'].quantile(0.75)
IQR = Q3 - Q1
upper_bound = Q3 + 1.5 * IQR
df['trip_cost'] = np.where(df['trip_cost'] > upper_bound, upper_bound, df['trip_cost'])

# Plot boxplot for trip cost
plt.figure(figsize=(8, 4))
df['trip_cost'].plot(kind='box', vert=False)
plt.title('trip_cost Distribution - Outliers Handled')
plt.show()

# Outlier Detection - Extra Tip

plt.figure(figsize=(8, 4))
df['extra_tip'].plot(kind='box', vert=False)
plt.title('Extra Tip Distribution')
plt.show()

df.shape

df.dtypes

# Plot the value_counts for different trip statuses
df['trip_status'].value_counts().plot(kind='bar')
plt.title("Trip Status Distribution")
plt.show()

# Trip Cost Distribution
max_cost = df['trip_cost'].max()
bins = np.arange(0, max_cost + 100, 100)

df['trip_cost'].hist(bins=bins, edgecolor='black')
plt.title("Trip Cost Distribution")
plt.xlabel("Trip Cost")
plt.ylabel("Frequency")
plt.grid(False)
plt.show()

# Analyze trip costs across payment methods by calculating the average, median, and number of trips for each method,
# and sort the results to highlight the most expensive payment types on average

df.groupby('payment_method')['trip_cost'].agg(['mean', 'median', 'count']).sort_values(by='mean', ascending=False)

# Compute the trip duration in minutes by taking the difference between drop and start timestamps
df['trip_duration_minutes'] = (df['drop_timestamp'] - df['start_timestamp']).dt.total_seconds() / 60

# Trip Duration
max_duration = df['trip_duration_minutes'].max()
bins = np.arange(0, max_duration + 10, 10)  # bins of size 10 minutes

df['trip_duration_minutes'].hist(bins=bins, edgecolor='black')
plt.title("Trip Duration Distribution")
plt.xlabel("Trip Duration (minutes)")
plt.ylabel("Frequency")
plt.grid(False)
plt.show()

# Calculate Total cost of the trip
df['total_cost'] = df['trip_cost'] + df['extra_tip']

# Convert Time Columns to DateTime Format

df['request_timestamp'] = pd.to_datetime(df['request_timestamp'])
df['start_timestamp'] = pd.to_datetime(df['start_timestamp'])
df['drop_timestamp'] = pd.to_datetime(df['drop_timestamp'])

# Extract Date and Time Components
'''
From the relevant datetime column(s), extract:
1. Date (YYYY-MM-DD) (request_date, start_date, drop_date)
2. Day of the week (e.g., Monday, Tuesday) (request_day, start_day, drop_day)
3. Exact time (HH:MM:SS) (request_time, start_time, drop_time)
4. Hour of the day (0–23) (request_hour, start_hour, drop_hour)
'''

df['request_date'] = df['request_timestamp'].dt.date
df['start_date'] = df['start_timestamp'].dt.date
df['drop_date'] = df['drop_timestamp'].dt.date

df['request_day'] = df['request_timestamp'].dt.day_name()
df['start_day'] = df['start_timestamp'].dt.day_name()
df['drop_day'] = df['drop_timestamp'].dt.day_name()

df['request_time'] = df['request_timestamp'].dt.time
df['start_time'] = df['start_timestamp'].dt.time
df['drop_time'] = df['drop_timestamp'].dt.time

df['request_hour'] = df['request_timestamp'].dt.hour
df['start_hour'] = df['start_timestamp'].dt.hour
df['drop_hour'] = df['drop_timestamp'].dt.hour

# Calculating the Ride delay.
'''
- Determine the delay between the ride request and actual trip start.
- Add a column ride_delay reflecting this delay in hour value.
'''
df["ride_delay"] = ((df["drop_timestamp"] - df["start_timestamp"]).dt.total_seconds() / 3600).round(2)

# Determine Cancellation reasons
# - Assign a cancellation reason to each trip based on the driver_id and trip_status columns using nested np.where() statements.
'''
1. If the driver_id is -1 and the trip status is 'No Cars Available', it indicates that no cab was assigned,
so the cancellation reason is set to 'No Cabs'.
2. If the driver_id is -1 and the trip status is 'Trip Cancelled', it means the passenger canceled the trip before a driver was assigned,
so the reason is 'Passenger'.
3. If a driver was assigned (driver_id not equal to -1) and the trip status is 'Trip Cancelled', it indicates that the driver canceled the trip,
so the reason is 'Driver'.
4. For all other cases—where the trip was completed successfully—the cancellation reason is set to 'Trip Completed'.

'''

df['cancellation_reason'] = np.where(
    (df['driver_id'] == -1) & (df['trip_status'] == 'No Cars Available'), 'No Cabs',
    np.where(
        (df['driver_id'] == -1) & (df['trip_status'] == 'Trip Cancelled'), 'Passenger',
        np.where(
            (df['driver_id'] != -1) & (df['trip_status'] == 'Trip Cancelled'), 'Driver',
            'Trip Completed'
        )
    )
)

# Creating a New Dataframe selecting columns relevant to our analysis
# All analysis going forward will be done on this new dataframe created

new_df = df[['request_id', 'driver_id', 'trip_status', 'request_day', 'request_hour','start_day', 'start_hour', 'drop_day', 'drop_hour', 'trip_cost',
            'ride_delay', 'weather', 'cancellation_reason']]

new_df.columns

# bar chart / Count plot (using Seaborn) that shows the number of ride requests for each day of the week (request_day column)
sns.countplot(
    new_df,
    x='request_day',
    hue='request_day',
    legend=False
)

plt.title("Request Count Vs Day")
plt.xlabel("Day of the Week")
plt.ylabel("Number of Requests")
plt.show()

# bar chart / Count plot (using Seaborn) that shows the number of ride requests for each day of the week (request_day column)
plt.figure(figsize = (12, 5))

sns.countplot(
    new_df,
    x='request_hour',
    hue='request_hour',
    palette='Blues',
    legend=False
)

plt.title("Request Count Vs Hour")
plt.xlabel("Hour of the Day")
plt.ylabel("Number of Requests")
plt.show()

#  trip status bifurcation (normalize to percentage)
trip_status_rates = new_df['trip_status'].value_counts(normalize=True) * 100
print(trip_status_rates)

plt.pie(trip_status_rates , labels = trip_status_rates.index, autopct = '%1.1f%%')

plt.title("Trip Status Bifurcation")
plt.show()

# cancellation trends based on the 'cancellation_reason' column & plot the same
cancellation_trends = new_df[new_df['trip_status'] == 'Trip Cancelled']['cancellation_reason'].value_counts()

print(f"Cancellation Trends (Driver vs Passenger):")
print(cancellation_trends)
plt.pie(cancellation_trends , labels = cancellation_trends.index, autopct = '%1.1f%%')
plt.title("Trip Cancellation Trend")
plt.show()

#reating a New Dataframe for only incomplete rides.

new_df = df[df['trip_status'] != 'Trip Completed']

new_df = new_df[[
    'request_id',
    'pickup_point',
    'drop_point',
    'driver_id',
    'trip_status',
    'payment_method',
    'weather',
    'request_day',
    'request_hour',
    'cancellation_reason'
]]

new_df.head()

# Proportion of Incomplete Rides’ Trip Statuses
Incomplete_rides_rate=new_df['trip_status'].value_counts(normalize=True)
plt.pie(Incomplete_rides_rate,labels=Incomplete_rides_rate.index,autopct='%1.1f%%',startangle=90)
plt.title('Proportion of Incomplete Ride Statuses')
plt.show()

'''Which is the day with the most rides cancelled?
What is the split of cancelled trips' status across days? '''

cancelled_rides = df[df['trip_status'] == 'Trip Cancelled']
sns.histplot(data=cancelled_rides, x='request_day',bins=7, hue='cancellation_reason', multiple='stack', palette='coolwarm')

plt.title('Incomplete Rides by Day and Reason')
plt.xlabel('Day')
plt.ylabel('Number of Incomplete Rides')
plt.show()

''' What are the times of the days with most rides cancelled?
What are the reasons for the cancellations throughout the day? '''
cancelled_rides = df[df['trip_status'] == 'Trip Cancelled']

plt.figure(figsize=(10, 6))

sns.histplot(data=cancelled_rides, x='request_hour',bins=24, hue='cancellation_reason', multiple='stack', palette='coolwarm')

plt.title('Incomplete Rides by Hour and Reason')
plt.xlabel('Hour of the Day')
plt.ylabel('Number of Incomplete Rides')
plt.show()

# Relationship Between Weather & Cancellation Reason
cancelled_trips = df[df['trip_status'] == 'Trip Cancelled']

grouped = cancelled_trips.groupby(['weather', 'cancellation_reason']).size().reset_index(name='count')

sns.barplot(data=grouped, x='weather', y='count', hue='cancellation_reason',palette='Set2')

plt.title('Cancellations by Weather and Reason per Ride Type')
plt.xlabel('Weather Conditions')
plt.ylabel('Count of Cancellations')
plt.legend(title='Cancellation Reason')
plt.show()

# Weather Impact on Trips
df.groupby('weather')['trip_status'].value_counts(normalize=True).unstack().plot(kind='bar', stacked=True)
plt.title("Trip Completion vs Weather Condition")
plt.show()

# Most common pickup and drop point
df['pickup_point'].value_counts().head(10)
df['drop_point'].value_counts().head(10)
sns.countplot(y=df['pickup_point'], order=df['pickup_point'].value_counts().head(10).index)
plt.title("Top 10 Pickup Locations")
plt.show()

sns.countplot(y=df['drop_point'], order=df['drop_point'].value_counts().head(10).index)
plt.title("Top 10 Drop Locations")
plt.show()

sns.countplot(y=df['pickup_point'], order=df['pickup_point'].value_counts().head(10).index)
sns.countplot(y=df['drop_point'], order=df['drop_point'].value_counts().head(10).index)
plt.title("Top 10 Pickup and Drop Locations - combined")
plt.show()

# Ride Type Insights
df.groupby('ride_type')['trip_cost'].agg(['mean', 'count']).sort_values(by='mean', ascending=False)

# Driver Performance Overview
driver_summary = df.groupby('driver_id').agg({
    'trip_cost': 'sum',
    'request_id': 'count',
    'extra_tip': 'sum'
}).rename(columns={'request_id': 'num_trips'})

driver_summary.sort_values(by='trip_cost', ascending=False).head(10)

# Weekday vs Weekend Behavior
df['is_weekend'] = df['day'].isin(['Saturday','Sunday'])
df.groupby('is_weekend')[['trip_cost','ride_delay','total_cost']].mean()

# Trip Duration Trend Over Time
avg_duration = df.groupby('request_date')['trip_duration_minutes'].mean()
avg_duration.plot(figsize=(10,5))
plt.title("Average Trip Duration Over Time")
plt.ylabel("Duration (minutes)")
plt.show()

# Total Cost Trend by Ride Type
df.groupby(['ride_type', 'day'])['total_cost'].mean().unstack().T.plot(figsize=(10,5))
plt.title("Average Total Cost by Ride Type Across Days")
plt.ylabel("Average Total Cost (₹)")
plt.show()

# Ride Delay Correlation Heatmap
corr = df[['trip_cost','extra_tip','trip_duration_minutes','ride_delay','total_cost']].corr()
sns.heatmap(corr, annot=True, cmap='coolwarm')
plt.title("Correlation Between Key Metrics")
plt.show()

